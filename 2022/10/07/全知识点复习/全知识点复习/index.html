<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="JAVA基础：    基础：        1.面向对象的三个基本特征：封装、继承和多态;            继承：子类继承父类的属性和方法,使得子类具有父类相同的行为;            封装：隐藏部分对象的属性和实现细节,对数据的访问只能通过对外公开的接口,通过这种方式可以对对象内部数据提供不同级别的保护并且能够减少冗余代码;            多态：对于同一个行为,不同的子类对象">
<meta property="og:type" content="article">
<meta property="og:title" content="全知识点复习">
<meta property="og:url" content="https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="祥祥要起飞">
<meta property="og:description" content="JAVA基础：    基础：        1.面向对象的三个基本特征：封装、继承和多态;            继承：子类继承父类的属性和方法,使得子类具有父类相同的行为;            封装：隐藏部分对象的属性和实现细节,对数据的访问只能通过对外公开的接口,通过这种方式可以对对象内部数据提供不同级别的保护并且能够减少冗余代码;            多态：对于同一个行为,不同的子类对象">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-07T02:30:38.000Z">
<meta property="article:modified_time" content="2022-10-25T08:39:57.851Z">
<meta property="article:author" content="祥祥要起飞">
<meta property="article:tag" content="Spring, Mybatis, Dubbo, Spring Cloud, redis, Elasticsearch, rabbitmq">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>全知识点复习</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
      <link rel="alternate" href="/atom.xml" title="祥祥要起飞" type="application/atom+xml" />
    
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/10/25/kafka/Apache%20Kafka%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%8F%8A%E7%94%A8%E9%80%94/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/09/27/MySql/MySQL%E4%BA%8B%E5%8A%A1/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&text=全知识点复习"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&is_video=false&description=全知识点复习"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=全知识点复习&body=Check out this article: https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&name=全知识点复习&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        全知识点复习
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">祥祥要起飞</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-07T02:30:38.000Z" itemprop="datePublished">2022-10-07</time>
        
      
    </div>


      <div class="posteye">
    <i class="fas fa-eye"></i>
    <span id="/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/" class="leancloud-visitors" data-flag-title="全知识点复习" style="display: inline;">
        <span class="leancloud-visitors-count"></span>
    </span>
</div>
      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>JAVA基础：<br>    基础：<br>        1.面向对象的三个基本特征：封装、继承和多态;<br>            继承：子类继承父类的属性和方法,使得子类具有父类相同的行为;<br>            封装：隐藏部分对象的属性和实现细节,对数据的访问只能通过对外公开的接口,通过这种方式可以对对象内部数据提供不同级别的保护并且能够减少冗余代码;<br>            多态：对于同一个行为,不同的子类对象具有不同的表现形式。多态存在的三个条件：1.继承、2.重写、3.父类引用指向子类对象;<br>        2.访问修饰符：<br>            public:当前类，同包，子类，其他包<br>            private:当前类<br>            protected:当前类，同包，子类<br>            不写：当前类，同包<br>        3. shrot s1 = 1; s1 = s1 + 1;<br>           short s1 = 1; s1 += 1;<br>        4. Integer缓存值-128 ~ 127<br>        5. 用最有效率的方式计算2乘以8；<br>        6. &amp;和&amp;&amp;的区别<br>            &amp;&amp;逻辑与运算符,同为true返回true,并且具有短路性;<br>            &amp;按位与运算符,相同为1,不同为0;<br>        7. Java基本数据类型(String不是)有哪些：<br>            基本数据类型：数据直接存储在栈上<br>            引用数据类型：数据存储在堆上,地址存在栈上<br>        8. String可以被继承吗,不可以,String类使用final修饰,无法被继承;<br>        9. String和StringBuilder和StringBuffer:<br>        10. String s = “xyz” 和 String s = new String(“xyz”);<br>        11. ==和equals的区别<br>            ==：基础类型的变量,比较变量保存的值是否相同,类型不一定相同;<br>                引用类型的变量：比较两个对象的内存地址是否相同;<br>            equals:Object类中定义的方法,通常用于重写来比较两个变量的值是否相同;<br>        12. 两个对象的HashCode()相同,则equal()也一定为true吗？<br>            不对,两个对象equal为true,则HashCode一定相同;<br>            不同字面值的两个对象可能HashCode相同,但是equal不为true;<br>        13. 什么是反射<br>            反射是指在运行状态中,对于某个类能够知道它的属性和方法,并且能够调用它的方法,这种动态获取对象信息以及动态调用对象方法的功能称之为反射;<br>        14. 深拷贝和浅拷贝<br>        15. 并发和并行有什么区别<br>        16. 构造器是否可以被重写 — 不可以,但是可以被重载<br>        17. 静态变量和成员变量的区别<br>        18. 重载和重写的区别<br>        19. 抽象类和接口设计思想的区别<br>        20. Error和Exception有什么区别<br>        21. final关键子<br>        22. final、finally、finalize的区别<br>        23. JDK1.8之后有哪些新特性<br>        24. wait和sleep方法的区别<br>            1. 对于同步锁的影响不同;<br>            2. 使用范围不同;<br>            3. 恢复方式不同;<br>        25. 线程的Sleep方法和yield方法有什么区别<br>            sleep方法是线程进入超时等待状态(TIMED_WAITING),yield方法使线程让出CPU进入就绪(READY)状态,任然有可能继续被cpu选中继续执行;<br>        26. 线程join方法的作用<br>            线程A执行threadB.join(),需要等待ThreadB线程终止之后才能继续往下执行自己的代码;<br>        27. 创建线程的几种实现方式<br>            1. 继承Thread类,重写run方法;<br>            2. 实现Runnable接口,重写run方法;<br>            3. 实现Callable接口,重写call方法,并且有返回值,一般配合Future阻塞获取返回值;<br>            4. 自定义线程池或者使JDK的Executors(线程池的工厂)构建JDK定义的线程池;<br>            5. 使用Spring封装的ThreadPoolTaskExecutor,一般项目会定义线程池配置类使其注入Spring容器成为Spring的单例Bean,可以在配置类中配置线程池相关的参数;<br>        28. Thread调用start()方法和调用run()方法的区别<br>        29. 死锁的四个必要条件<br>        30. 怎么预防死锁<br>        31. 为什么使用线程池<br>            1. 重复利用已创建的线程,降低线程的创建和销毁带来的消耗;<br>            2. 提高响应速度,当任务到达时,任务可以不需要线程的就可以立即执行;<br>            3. 增加线程的可管理性,进行统一分配;<br>        32. 如何自定义线程池<br>            1. new ThreadPoolExecutor,为其设置核心线程数, 最大线程数, 非核心线程的最大空闲时间, 时间单位,<br>            合适的阻塞队列(通常有LinkedBlockQueue, ArrayBlockingQueue, SynchronousQueue等),使用默认的线程工厂或者自定义线程工厂,使用默认的拒绝策略或者使用自定义拒绝策略,<br>            JDK默认的拒绝策略有4种：1. Abort,直接抛出RejectedExecutionException异常,调用者可以捕获这个异常,然后根据需求编写自己的处理代码; 2. Discard,扔掉,不抛异常; 3. DiscardOldest:扔掉排队时间最久的; 4. CallerRuns:调用者处理任务;<br>            2. 实现ThreadFactory接口来自定义线程工厂,通常最主要的是为线程名称设置业务前缀,方便排查问题;<br>            3. 实现RejectedExecutionHandler接口自定义拒绝策略;<br>        33. 实现线程间数据交换<br>            1. Exchanger<br>            2. SynchronousQueue, A线程向Queueput数据,阻塞等待其他线程取数据,B线程从Queue中取数据;<br>        34. 线程池的线程数量该设置为多少:<br>            线程池的线程数目多少需要当前服务器核数,预计CPU利用率,IO的等待时间与CPU的计算时间的比值以及具体业务作为参考来决定,Java并发编程实战这本书中给出了一个线程池数目的经验估算：<br>            线程数目 = CPU处理器数量 * CPU的利用率 * (1 + IO的等待时间/CPU的计算时间)<br>            线程数目还与业务属于IO密集型还是计算密集型有关;<br>            公式只是一种参考标准，最终的线程数目还要取决与实际压测的结果;</p>
<pre><code>集合,容器：
    1. List,Set,Map三者的区别
        List接口用于存储一组不唯一的有序对象;
        Set接口用于存储一组不同重复的对象;
        Map用于存储键值对;
    2. ArrayList和LinkedList的区别
        1. ArrayList基于动态数组实现的,LinkedList基于链表实现的;
        2. ArrayList可以通过index下标找到数据位置,但是从中间插入数据时需要copy后面所有的节点,LinkedList查找数据需要遍历链表,但是插入操作则只需要改变指针的指向;
        3.但是顺需插入的时候,ArrayList不需要copy后面的元素,所以实际业务中ArrarList相较于LinkedList应用的更多;
    HashMap
    在存储键值对时要尽量避免Hash碰撞,这样的话查找效率更高,HashMap尽量避免Hash碰撞的核心主要在于元素的分布策略和动态扩容:分布策略的优化方式为：1. 将HashMap的数组长度始终保持为2的整数次幂; 2. 将Hash值的高位参与运算; 3. 通过位与操作来等价与取模操作; 在动态扩容方面：由于底层数组始终为2的整数次幂,也就是每次扩容长度都是原来的2倍,因此数组长度length的二进制表示会在高位多出1bit,在扩容时length值会参与位于操作来确定元素所在数组的新位置,所以原数组的元素所在位置要么保持不动,要么就是移动2的次幂个位置,这样就能提高动态扩容的效率;
    由于链表的查询时间复杂度时O(n),为了提高在节点较多时的查找效率,在链表节点数大于8的时候会转化为红黑树,红黑树的查找效率是O(logn),节点数为这个和泊松分布有关,这种设计也是内部开发者在空间开销和时间开销上的一个取舍;
    但是HashMap美中不足的是不是线程安全的,在多线程环境下会出现环形链表的情况,在多线程put操作时也比较容易出现脏数据读写问题;
    HashMap头插法造成链表成环：假设线程1和线程2同时put操作导致数组扩容,假设某个桶位下的a指向b,由于JDK1.7采用的是头插法,线程1扩容后就变成b指向a,此时线程2执行扩容,此时首先遍历到头节点b,它会将b指向链表的下一个节点a,然后遍历到a,它会把a插到头部,此时头节点是b,它会将a指向节点b,这时候就出现了链表成环,当再次出现向该数组下标位置put数据时就会出现死循环;
容器内对象排序:

多线程,JUC,线程池：

volatile:
</code></pre>
<p>设计模式：</p>
<p>定时任务：一般会使用Spring的@Scheduled然后配置cron表达式,它底层是基于quartz来实现的</p>
<p>反射：<br>    1. 反射的三种方式:<br>        实例对象.getClass()来获取Class对象;<br>        类名点.class来获取Class对象;<br>        Class.forName(“类路径”)来获取Class对象;</p>
<p>多线程：<br>    什么是线程<br>    什么是进程<br>    什么是纤程<br>    1. 线程创建的6种方式<br>        1. new<br>        2. runable<br>        3. waiting<br>        4. time waiting<br>        5. blocked<br>        6. terminated<br>    2. Java的6种线程状态<br>    3. 如何保证线程的执行顺序<br>    线程池源码</p>
<p>###强引用<br>    理解：我们正常自定义的class类对应的对象都是强引用</p>
<p>###软引用<br>    理解：当JVM内存空间不足的时候，会回收软引用指向对象的内存空间</p>
<p>###弱引用<br>    理解：当没有强引用指向弱引用指向的对象时，在下次GC的时候就会被回收</p>
<p>###虚引用<br>    一个对象是否由虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来获取一个对象实例,为一个对象设置虚引用的唯一目的就是就是在这个对象被回收时收到一个通知;<br>    理解：虚引用主要用来跟踪对象何时被垃圾回收器回收的；声明虚引用的时候是要传入一个queue，当你的虚引用所引用的对象被回收时，<br>    会被加入到这个queue中，可以通过判断queue里面是不是有对象来判断对象是不是被回收；<br>    应用场景假设：如果我们在使用堆外内存的时候，对象使用完需要释放内存时，无法通过JVM来回收内存，这个时候我们就可以使用虚引用<br>    来确定回收堆外内存的时机，然后调用Unsafe类的freeMemory(long var1)方法来回收内存；</p>
<p>锁：<br>    1. 什么是锁<br>        在并发环境下,多个线程会对同一个资源进行争抢，那么会导致数据不一致的问题,为了解决这个问题，很多编程语言都引入锁机制，通过一种抽象锁，来对资源进行锁定;<br>    2. Java锁机制<br>        JVM运行时内存结构,那些区域数据是所有线程共享的,那些区域是线程独有的;<br>        锁是一种抽象概念,在代码层面是如何实现的呢?<br>        简单来说,在Java中,每个object也就是每个对象都拥有一把锁,这把锁存放在对象头中，锁中记录了这把锁被哪个线程所占用;这里谈到了对象头，那么我就来讲解一下对象和对象头的结构分别是什么?<br>        对象：Java普通对象包含三部分内容：对象头,实例数据,对齐填充字节;<br>        其中对齐填充字节是为了满足”Java对象的大小必须是8比特的倍数”这一条件而设计的;<br>        实例数据：就是在初始化对象时设定的属性和方法等内容;<br>        对象头：存放了对象本身的运行时信息,主要由Mark word和Class pointer类型指针两部分构成;<br>        Class pointer:它指向了当前对象类型所在方法区中的类型数据;<br>        Mark work存储了很多和当前对象运行时信息有关的数据,比如说：HashCode,对象分代年龄,锁状态标志,偏向锁标志位,偏向锁对应的线程ID,指向锁记录的指针等等;<br>        为了节省空间，Mark word只有32bit,并且他是非结构化的，在不同的锁标志位下,不同的字段可以重用不同的比特位<br>        Mark word的锁标志位分别对应了四种锁状态：无锁，偏向锁，轻量级锁和重量级锁;<br>    3. synchronized<br>           synchronized在编译后会生成monitorenter和moniterexit两个字节码指令,依赖这两个字节码指令来进行线程同步<br>           Moniter通常被称之为管程或者监视器,我通常将它理解为同时只能容纳一个线程的小容器，只有其中线程退出Moniter,其他线程才有进入的机会;<br>           这样就会导致synchronized可能存在性能问题,Moniter是依赖于操作系统的mutex lock来实现的,Java线程实际上是对操作系统线程的映射，所以每当挂起或者唤醒一个线程,都要切换操作系统内核态，这种操作是比较重量级的，在一些情况下，在一些情况下甚至切换时间本身将会超出线程执行任务的时间,这样的话使用synchronized的话将会对程序的性能产生很严重的影响;<br>           从Java6开始,synchronized进行了优化,引入了偏向锁和轻量级锁,所以锁总共有四种状态，分别是无锁，偏向锁，轻量级锁和重量级锁,这也分别对应了Mark word中的四种状态,需要注意的是锁只能升级不能降级;<br>           无锁：资源不会出现在多线程竞争环境下,无需加锁;<br>           偏向锁：对象一直被同一个线程访问,那么mark word中会记录这个线程id,可以理解对象偏爱这个线程;<br>           轻量级锁：当访问对象的线程发现mark word中的记录不是自己的线程id,此时发生资源竞争，那么偏向锁就会生成轻量级锁,这时mark word中记录线程与锁的绑定关系也发生了变化,mark word中不在记录线程id的值，而是变成记录指向线程栈中锁记录的指针,升级成轻量级锁时,线程会在自己虚拟机栈中开辟一块被称为Lock Record的空间,Lock record中存放的是对象头中Mark word副本以及owner指针,线程通过CAS来获取锁,一旦获取到锁就会复制对象头中的Mark word到Lock Record中,并且将owner指针指向该对象,这样就实现了线程和对象锁的绑定,这时这个对象已经被锁定了,获取了这个对象锁的线程就可以去执行一些任务,其他获取锁的线程就会自旋等待,自旋相当于cpu空转，如果长时间自旋将会浪费CPU资源(适应性自旋);<br>           重量级锁：如果线程自旋超过一定次数或者不止一个线程在自旋则会升级为重量级锁，此时就需要通过Moniter同步监视器来对线程进行控制;<br>    4. 悲观锁<br>        主要是指互斥锁,操作系统会悲观的认为如果不严格同步线程调用，那么一定会产生异常，所以互斥锁将会将资源锁定,只供一个线程调用,而阻塞其他线程,这种同步机制被称之为悲观锁;<br>        悲观锁并不是万能的：比如：1. 在有些情况下大部分操作都是读操作，那就没有必要在每次调用的时候都锁定资源；<br>        2. 在一些情况下同步代码块执行的耗时远远小于线程切换的耗时，那么这就有点本末倒置了;<br>    5. 乐观锁<br>        不会锁定资源,当线程需要修改共享资源的对象时，总是会乐观的认为对象状态值没有被其他线程修改过，每次都会去尝试compare状态值,当比较状态值匹配成功时才会去执行具体的数据操作;在实际的主要应用是CAS;<br>        乐观锁不需要调用操作系统的mutex原语来实现同步，减少操作系统内核态和用户态的切换，在很多情况下极大提升了多线程并发的性能;<br>    7. CAS<br>        CAS操作的几个关键参数：<br>        old value：代表之前读到的资源对象的值;<br>        new value：代表要将资源对象更新后的状态值;<br>        线程首先会将old value与资源对象的状态值进行比较,发现一致,则将数据进行修改,不一致则自旋后再次尝试,通常会配置自旋次数来防止死循环，默认是10;<br>        CAS是必须保证比较数值并更新数据同时只有一个线程可以操作,也就是CAS必须是原子性的,各种架构的CPU都提供了指令级别的CAS原子操作,在X86架构下，通过cmpxchg指令来支持cas,在ARM架构下,通过LL/SC来实现CAS,也就是说不需要通过操作系统的同步原语(比如mutex),CPU已经原生的支持了cas,上层进行调用即可;这样就能不再依赖锁来进行线程同步;<br>    8. AQS<br>        全名AbstractQueuedSynchronizer,我个人将其理解为一个实现多线程同步机制的队列容器框架,内部通过FIFO队列来维护所有请求共享资源线程的阻塞与唤醒,通过CAS操作来维护队列中的节点和修改线程状态,来保证线程安全;它的核心方法主要有tryAcquire(),acquire(),tryRelease(),release();其中tryAcquire(), tryRelease()都是空方法,主要提供给上层来进行实现，常见的实现类有ReentrantLock, ReentrantReadWriteLock, ThreadPoolExecutor; acquire和release的实现依赖于tryAcquire和tryRelease,内部调用了tryAcquire,但是tryAcquire不同的是acquire获取所失败后会被加入队列进行阻塞;另外AQS还分为独占模式和共享模式,AQS框架中存在一个状态值state,代表同步状态,独占模式下锁只能被一个线程获取,其他线程都必须等待,共享模式下,锁可以被多个线程获取,表现为state值的增加,用完需要一一释放,独占模式下,锁释放后,只会把将要出队的线程唤醒,共享模式下,会唤醒所有处于挂起状态的线程;总体来说,我对AQS的理解它是一个提供了获取锁，释放锁实现线程同步管理的抽象模板框架;<br>JUC:<br>    1. ReentrantLock<br>        ReentrantLock基于AQS,在并发编程中它可以实现公平锁和非公平锁来对共享资源进行同步,同时,和synchronized一样，ReentrantLock支持可重入,除此之外，ReentrantLock在调度上更加灵活，支持更多丰富的功能;<br>        ReentrantLock通过内部的state状态来记录锁的重入次数,ReentrantLock拥有3个内部类Sync, NonfairSync, FairSync,其中NonfairSync, FairSync分别是ReentrantLock在非公平模式和公平模式下的具体实现;ReentrantLock默认构造函数采用的是非公平模式，也可以通过传参来决定采用公平模式还是非公平模式;<br>    2. 公平锁<br>        锁的分配按照请求锁的顺序,拥有稳定的获取锁的机会,但是性能可能比公平锁低,AQS中的FIFO队列就能实现公平锁;<br>    3. 非公平锁<br>        锁的分配不用按照请求锁的顺序,是抢占式,很可能某个线程一直拿不到锁,而又有新的线程加入进来抢锁,导致该线程一直处于阻塞状态,但是它的性能可能比公平锁高;<br>    4. 为什么有非公平锁的存在<br>        线程的切换存在现场保存和恢复,公平锁严格的按照请求的顺序获取锁，大量的线程需要进入阻塞状态，而非公平锁则有些线程直接获取到锁，减少了现场恢复和用户态内核态间的切换;<br>    5. CountDownLatch<br>    6. ConcurrentHashMap<br>        ConcurrentHashMap内部维护了一个Segment数组,该数组的每一个元素是HashEntry数组,结构与HashMap类似,它采用了分段锁机制,每个Segment元素都是一把锁,每一个Segment元素对应着一个HashEntry数组,这个数组中的元素依赖于同一把锁,不同HashEntry数组的读写互不干扰,这就形成所谓的分段锁,假设Segment数组长度为n,那么相较于HashTable,理论上ConcurrentHashMap的性能提升n倍以上,这里之所以说n倍以上,相较与HashTable的synchronized,ConcurrentHashMap对锁本身也做了优化,Segment对象继承自ReentrantLock,通过这一点可以了解到Segment同步数据是借助于ReentrantLock工具包来实现了的,ConcurrentHashMap内部还定义了重试次数属性值,当线程没有获取到锁时也不会死等,会通过tryLock的方式来进行尝试获取锁,另外ConcurrentHashMap还做出其他优化,在线程put操作没有获取到锁时,会检查key是否存在,如果不存在会预创建节点,这也就减少等待线程获取到锁后的操作时间从而提升了效率;</p>
<p>网络:<br>    1. TCP<br>    2. HTTP<br>    3. HTTPS<br>    4. 常见的负载均衡算法(轮询、随机、hash、一致性hash)<br>    5. 常见的hash算法<br>    6. 一致性hash</p>
<p>MySQL:</p>
<ol>
<li>事务及主从复制<ol>
<li>什么是事务</li>
<li>事务特性（ACID）</li>
<li>事务并发引发的问题</li>
<li>MySQL中的隔离级别</li>
<li>MySQL保存点</li>
<li>MySQL隐式提交</li>
<li>MVCC(Multi-Version Concurrency Control - 多版本并发控制)</li>
<li>ReadView(读视图)</li>
<li>不同事务隔离级别下MySQL是如何解决脏读,不可重复读的</li>
<li>redo log</li>
<li>undo log</li>
<li>binlog</li>
<li>MySQL崩溃后的恢复</li>
<li>MySQL主从复制原理(执行流程)</li>
<li>主从复制延迟问题的产生</li>
<li>如何解决主从复制延迟问题</li>
<li>MySQL中的锁(行锁,表锁,意向独占锁,意向共享锁,间隙锁)</li>
<li>MyISAM与InnoDB的区别</li>
<li>UNION和UNION ALL的差别</li>
</ol>
</li>
<li>索引<ol>
<li>MySQL添加索引的语句</li>
<li>索引是什么</li>
<li>索引的数据结构及为什么使用B+树</li>
<li>聚簇索引与非聚簇索引</li>
<li>二级索引/普通索引和联合索引</li>
<li>回表</li>
<li>覆盖索引</li>
<li>自适应Hash索引</li>
</ol>
</li>
<li>性能调优<ol>
<li>Explain执行计划(分析各个字段的含义及常见的情况)</li>
<li>字段数据类型优化</li>
<li>高性能索引创建策略</li>
<li>高性能索引使用策略<ol>
<li>不要在查询条件索引列上做任何操作：比如：计算,sql函数等；</li>
<li>覆盖索引尽量用上：尽量不要使用*</li>
<li>最佳左前缀法则：(由于联合索引在B+树中前面列的顺序对后面列的顺序是有影响的)<br> 当我们项目有大量的查询同时用到name和age来进行查询,此时可以创建name和age的组合索引,<br> select * from emp where name = ? AND age = ?  //走的上索引 — 这里查询优化器会自动优化查询顺序,name和age更换位置也可以<br> select * from emp where age = ?  // 走不上索引<br> select * from emp where name = ?  // 走的上索引</li>
<li>不等于要慎用：使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>
<li>字符类型加引号：隐式类型转换导致索引失效;</li>
<li>like条件尽量右模糊：一般模糊查询的话都是字符串类型，右模糊的话还可以利用上索引的前缀,左模糊则用不上;</li>
<li>尽可能按主键顺序插入行：插入已存在数据的中间值,导致页内数据移动导致页分裂;</li>
<li>count(※)和count(列)效率几乎一样,但是统计结果会有差别,count(※)会统计含null值的列,count(列)不会统计当前列值为null的列,所以统计结果会有差别;</li>
</ol>
</li>
<li>覆盖索引</li>
<li>最左匹配原则</li>
<li>为什么要尽量使用自增主键做索引(页分裂)</li>
</ol>
</li>
<li>MySQL分库分表<ol>
<li></li>
</ol>
</li>
</ol>
<p>Redis:<br>    1. IO多路复用模型<br>    2. redis常见的数据结构<br>    3. redis单线程为什么也很快<br>    4. 缓存穿透<br>    5. 缓存击穿<br>    6. 缓存雪崩<br>    7. redis分布式锁<br>    8. 缓存淘汰策略<br>    9. redis如何删除过期的key的<br>    10. redis持久化<br>    11. redis分布式部署要解决的问题<br>    12. 过半机制<br>    13. 一致性Hash<br>    14. redis事务<br>    15. redis集群代理<br>    16. Hash算法有哪些<br>    17. Redis-cluster的数据分片<br>    18. redis客户端<br>    19. 数据库缓存双写不一致问题<br>        1. 同步删除(更新数据立即删除缓存):<br>            1. 并发场景下存在脏数据;(线程1查询到数据库a = 1,线程二更新数据库a = 2,删除缓存,线程1将读到a = 1写到缓存)<br>            2. 难以收拢所有更新数据库的入口,比如通过命令行或者公司提供的刷数据的数据库平台;<br>            3. 删除缓存失败存在脏数据;<br>        2. 同步删除 + 异步监听binlog(Canal)删除缓存 + 缓存处理失败的key使用MQ重试<br>        3. 如果想要更完美一点,可以延迟n秒后使用MQ服务进行数据一致性校验;</p>
<p>JVM:<br>    1. JVM运行时数据区<br>        存储器的层次结构：<br>        多线程一致性硬件层的支持：<br>        缓存行：<br>        伪共享：<br>        使用缓存行的对齐提高效率：<br>        指令重排序：<br>        合并写：<br>        为什么需要合并写技术：<br>        利用合并写技术提高程序执行效率：<br>        硬件级别保证有序：<br>        volatile实现细节：<br>        lock前缀指令在cpu级别做了什么：<br>        synchronized实现细节：<br>    2. Java类加载机制<br>        1. JVM,JRE,JDK<br>        2. 类加载过程<br>        3. 对象的创建过程<br>        4. JVM的懒加载<br>        5. 类加载器的分类：<br>        6. 双亲委派机制<br>        7. 为什么要使用双亲委派机制：<br>        8. 打破双亲委派机制：<br>        9. Launcher：<br>        10. Java是解释执行的语言还是编译执行的语言<br>    3. JVM运行时内存结构<br>        1. 常见的出现OOM、SOF的场景<br>        2. 程序计数器：<br>        3. JVM栈，用于存放栈帧：<br>        4. 本地方法栈：<br>        5. 堆：<br>        6. 方法区：<br>        7. 栈帧：<br>    4. JVM垃圾回收相关<br>        1. 垃圾的定义<br>        2. 为什么要分代<br>        3. JVM常见的优化指标<br>            低延迟,更短的响应时间：<br>            高吞吐量：<br>            高可用：<br>        4. Card Table<br>        5. 定位垃圾的算法<br>        6. 常见的GC Root有哪些<br>            1.线程栈中的变量;<br>            2.静态变量;<br>            3.常量池中对象;<br>            4.本地方法栈中引用的对象;<br>            5.所有被同步锁Synchronized持有的对象<br>        7. 常见的垃圾回收算法<br>        8. JVM内存分代模型(用于分代垃圾回收算法)<br>        9. 各个区比例,如何指定各个区域的大小<br>        10. 对象在各分区GC流程<br>        11. 栈上分配<br>        12. 线程本地分配TLAB(Thread Local Allocation Buffer)<br>        13. 对象何时进入老年代<br>        14. 安全点<br>        15. 常见的垃圾收集器<br>        16. CMS回收器(低延迟)<br>        17. G1垃圾回收器<br>        18. G1如果产生FGC，应该怎么做<br>        19. G1的Collection Set<br>        20. RememberedSet<br>        21. 并发标记算法(三色标记)<br>    5. JVM调优相关<br>        1. 各分代区域大小对业务的影响：<br>        2. 配置详细的线上GC日志：<br>        3. 如何配置线上的监控告警：<br>        4. 调优时的注意点(调优后先在测试环境或者预发环境运行观察,然后先在线上的单个节点上运行观察情况,没有出现问题,陆续调整线上其他节点的GC配置)<br>    6. JVM常用参数<br>        GC常用参数<br>    7. 实际线上调优经验</p>
<p>Spring:<br>    BeanFactoryPostProcessor<br>    BeanPostProcessor<br>    FactoryBean与BeanFacotry<br>    Spring怎样解决循环依赖的<br>    Spring AOP<br>    AOP 拦截器链<br>    声明式事务<br>    全局异常拦截：@ControllerAdvice搭配@ExceptionHandler(Exception.class)<br>    要在Spring IOC容器执行完毕之后执行一些逻辑怎么实现<br>        1. 实现ApplicationListener接口,监听ContextRefreshedEvent事件;<br>        2. 实现SmartLifecycle接口,这个接口内部提供了isAutoStartup方法和stop方法来对容器的初始化完成和关闭提供感知;</p>
<p>Mybatis:<br>    怎样返回插入数据的主键：insert标签配置useGennerKey=true,keyProperty=id;<br>    mybatis中的DAO接口和XML文件里的SQL是如何建立关系:</p>
<p>Spring Cloud:<br>    后续的Sentinel等组件都以Nacos为注册中心;<br>    Nacos: 注册中心+配置中心组合, @EnableDiscoveryClient, Nacos自带负载均衡, 远程调用与Ribbon,要注意的是Nacos已经整合了Ribbon,现在如果我们需要远程访问那么可以使用RestTemplate,@LoadBalanced,<br>    restTemplate.getForObject(arg1,arg2,arg3…);<br>    第一个参数url表示被调用的目标Rest接口位置,<br>    第二个参数是返回值类型,<br>    第三个参数是可变参数,<br>    Nacos可以通过以下命令来实现CP与AP之间的切换<br>    curl -X PUT ‘$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&amp;value=CP’<br>    修改Nacos配置，不需要重启项目即可自动刷新<br>    如果启动多个默认配置下的Nacos节点，数据储存存在一致性问题，为了解决这个问题，Nacos采用了集中存储方式来支持集群化部署，目前仅支持MySql的存储<br>    Nacos默认derby切换MySql</p>
<pre><code>Sentinel: 
    Sentinel以“流量”为切入点,对流量进行监控和配置以及服务的治理来保障服务的可靠性;
    Sentinel以“流量”为切入点,在流量控制、断路、负载保护等多个领域开展工作，保障服务可靠性。
    丰富的应用场景:秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰、集群流量控制、实时熔断下游不可用应用等。
    完备的实时监控：Sentinel同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据;
    广泛的开源生态：Sentinel提供开箱即用的与其它开源框架/库的整合模块;
    完善的SPI扩展机制：Sentinel提供简单易用、完善的SPI扩展接口;

    Sentinel初始化监控:
        1. Sentinel服务注册到注册到Nacos;
        2. 配置Sentinel dashboard地址及端口;
    Sentinel流控规则:
        资源名：具体的URL路径
        针对来源：对调用者进行限流,填写微服务名,默认default(不区分来源)
        阈值类型：
            QPS(每秒钟的请求数量):当调用该API的QPS达到阈值的时候，进行限流
            线程数(一次处理多少个请求):当调用该API的线程数量达到阈值的时候，进行限流
        是否为集群:
        流控模式:
            直接: API达到限流条件时，直接限流
            关联: 当关联的资源达到阈值时，就限流自己
            链路: 只记录指定链路上的流量（指定资源从入口资源进来的流量,如果达到阈值,就进行限流）(API级别的针对来源)
        流控效果:
            快速失败: 直接失败，抛异常
            Warm Up: 根据codeFactor(冷加载因子,默认3)的值,
                     从阈值/codeFacotor,经过预热时长,才达到设置的QPS阈值
            排队等待：匀速排队,让请求以匀速的速度通过,阈值类型必须设置为QPS,否则无效

        关联：配置关联资源(比如一个电商系统中，支付系统达到阈值，就限流下订单系统)
        链路：链路流控是针对上级接口,两个接口都调用了同一个Service中的方法，并且该方法用SentinelResource（用于定义资源）注解;为当我们用入口资源访问被SentinelResource注解标注的资源方法时，当超过阈值就会被限流。
        预热：可以设置预热时长，预热公式：阈值/coldFactor（默认值为3），经过预热时间后才会达到阈值。
        排队等待：这种方式主要用于处理间隔性突发的流量，例如消息队列。想象一下这样的场景，在某一秒有大量的请求到来，而接下来的几秒则处于空闲状态，我们希望系统能够在接下来的空闲期间逐渐处理这些请求，而不是在第一秒直接拒绝多余的请求（削峰填谷）

        熔断降级：
        熔断规则：
            resource：资源名，即规则的作用对象
            grade：熔断策略，支持慢调用比例/异常比例/异常数策略
        Sentinel持久化配置：Sentinel提供多种不同的数据源来持久化规则配置，包括file，redis、nacos、zk。

OpenFeign
    /**
     * 此接口就是配合使用OpenFeign的接口，
     * 在此接口中添加@FeignClient接口同时标注
     * 要调用的服务端名称，同时使用与服务提供者
     * 方法签名一致的抽象方法来表示远程调用的
     * 具体内容
     */
    @Service
    //表示远程调用服务名称
    @FeignClient(&quot;nacos-provider&quot;)
    public interface openFeignService &#123;
        /**
         * 此方法表示远程调用info/&#123;id&#125;接口
         */
        @GetMapping(&quot;info/&#123;id&#125;&quot;)
        public JsonResult&lt;String&gt; msbSql(@PathVariable(&quot;id&quot;) Long id);
    &#125;
GeteWay
    Route（路由）
    Predicate（断言）
    Filter（过滤）
        Filter在pre类型的过滤器可以做参数效验、权限效验、流量监控、日志输出、协议转换等。
        Filter在post类型的过滤器可以做响应内容、响应头的修改、日志输出、流量监控等
Seata
    2PC即两阶段提交协议，是将整个事务流程分为两个阶段，P是指准备阶段，C是指提交阶段
        准备阶段（Prepare phase）
        提交阶段（commit phase）
        就像MySQL一样,Undo Log记录提交前的数据，Redo log记录修改后的数据
    Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案
    要了解Seata，首先我们要了解一下Seata的几个关键的概念：
    TC (Transaction Coordinator) - 事务协调者
    维护全局和分支事务的状态，驱动全局事务提交或回滚。
    TM (Transaction Manager) - 事务管理器（发起者，同时也是RM的一种）
    定义全局事务的范围：开始全局事务、提交或回滚全局事务。
    RM (Resource Manager) - 资源管理器（每个参与事务的微服务）
    管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。
    Seata Server端存储模式（store.mode）支持三种
        1. file
        2. DB
        3. redis
    注册中心
    配置中心
    AT模式是一种无侵入的分布式事务解决方案，在AT模式下，用户只需关注自己的“业务SQL”，用户的 “业务SQL” 作为一阶段，Seata框架会自动生成事务的二阶段提交和回滚操作。
    一阶段
    在一阶段中，Seata会拦截“业务SQL“，首先解析SQL语义，找到要更新的业务数据，在数据被更新前，保存下来&quot;undo&quot;，然后执行”业务SQL“更新数据，更新之后再次保存数据”redo“，最后生成行锁，这些操作都在本地数据库事务内完成，这样保证了一阶段的原子性。
    二阶段
    相对一阶段，二阶段比较简单，负责整体的回滚和提交，如果之前的一阶段中有本地事务没有通过，那么就执行全局回滚，否在执行全局提交，回滚用到的就是一阶段记录的&quot;undo Log&quot;，通过回滚记录生成反向更新SQL并执行，以完成分支的回滚。当然事务完成后会释放所有资源和删除所有日志。
    TCC事务模式
    首先我们先来了解常规的TCC模式。
    什么是TCC
    TCC 是分布式事务中的二阶段提交协议，它的全称为 Try-Confirm-Cancel，即资源预留（Try）、确认操作（Confirm）、取消操作（Cancel），他们的具体含义如下：
    1. Try：对业务资源的检查并预留；
    2. Confirm：对业务处理进行提交，即 commit 操作，只要 Try 成功，那么该步骤一定成功；
    3. Cancel：对业务处理进行取消，即回滚操作，该步骤回对 Try 预留的资源进行释放。

    TCC 是一种侵入式的分布式事务解决方案，以上三个操作都需要业务系统自行实现，对业务系统有着非常大的入侵性，设计相对复杂，但优点是 TCC 完全不依赖数据库，能够实现跨数据库、跨应用资源管理，对这些不同数据访问通过侵入式的编码方式实现一个原子操作，更好地解决了在各种复杂业务场景下的分布式事务问题。
    ### TCC和AT区别

    AT 模式基于 **支持本地 ACID 事务** 的 **关系型数据库**：

    - 一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。
    - 二阶段 commit 行为：马上成功结束，**自动** 异步批量清理回滚日志。
    - 二阶段 rollback 行为：通过回滚日志，**自动** 生成补偿操作，完成数据回滚。

    相应的，TCC 模式，不依赖于底层数据资源的事务支持：

    - 一阶段 prepare 行为：调用 **自定义** 的 prepare 逻辑。
    - 二阶段 commit 行为：调用 **自定义** 的 commit 逻辑。
    - 二阶段 rollback 行为：调用 **自定义** 的 rollback 逻辑。

    所谓 TCC 模式，是指支持把 **自定义** 的分支事务纳入到全局事务的管理中。

    Seata 1.2.0 版本重磅发布新的事务模式：XA 模式，实现对 XA 协议的支持。

    我们从三个方面来深入分析：

    1. XA模式是什么？
    2. 为什么支持XA？
    3. XA模式如何实现的，以及如何使用？

    ## XA模式

    首先我们需要先了解一下什么是XA？

    XA 规范早在上世纪 90 年代初就被提出，用以解决分布式事务处理这个领域的问题。

    注意：不存在某一种分布式事务机制可以完美适应所有场景，满足所有需求。

    现在，无论 AT 模式、TCC 模式还是 Saga 模式，这些模式的提出，本质上都源自 XA 规范对某些场景需求的无法满足。

    ### 什么是XA协议

    XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准

    XA 规范 描述了全局的事务管理器与局部的资源管理器之间的接口。 XA规范 的目的是允许的多个资源（如数据库，应用服务器，消息队列等）在同一事务中访问，这样可以使 ACID 属性跨越应用程序而保持有效。

    XA 规范 使用两阶段提交（2PC，Two-Phase Commit）来保证所有资源同时提交或回滚任何特定的事务。

    XA 规范 在上世纪 90 年代初就被提出。目前，几乎所有主流的数据库都对 XA 规范 提供了支持。

    DTP模型定义如下角色：

    - AP：即应用程序，可以理解为使用DTP分布式事务的程序
    - RM：资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库的实例（MySql），通过资源管理器对该数据库进行控制，资源管理器控制着分支事务
    - TM：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理实务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。
    - DTP模式定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，基于数据库的XA协议来实现的2PC又称为XA方案。

    ![img](20200722160231749.png)

    案例解释：

    1. 应用程序（AP）持有订单库和商品库两个数据源。
    2. 应用程序（AP）通过TM通知订单库（RM）和商品库（RM），来创建订单和减库存，RM此时未提交事务，此时商品和订单资源锁定。
    3. TM收到执行回复，只要有一方失败则分别向其他RM发送回滚事务，回滚完毕，资源锁释放。
    4. TM收到执行回复，全部成功，此时向所有的RM发起提交事务，提交完毕，资源锁释放。

    ![image-20220209173222316](image-20220209173222316.png)

    #### XA协议的痛点

    如果一个参与全局事务的资源 “失联” 了（收不到分支事务结束的命令），那么它锁定的数据，将一直被锁定。进而，甚至可能因此产生死锁。

    这是 XA 协议的核心痛点，也是 Seata 引入 XA 模式要重点解决的问题。

    ### Seata的事务模式

    Seata 定义了全局事务的框架。

    全局事务 定义为若干 分支事务 的整体协调：

    1. TM 向 TC 请求发起（Begin）、提交（Commit）、回滚（Rollback）全局事务。
    2. TM 把代表全局事务的 XID 绑定到分支事务上。
    3. RM 向 TC 注册，把分支事务关联到 XID 代表的全局事务中。
    4. RM 把分支事务的执行结果上报给 TC。（可选）
    5. TC 发送分支提交（Branch Commit）或分支回滚（Branch Rollback）命令给 RM。

    ![seata-mod](TB19qmhOrY1gK0jSZTEXXXDQVXa-1330-924.png)

    Seata 的 全局事务 处理过程，分为两个阶段：

    - 执行阶段 ：执行分支事务，并保证执行结果满足是 *可回滚的（Rollbackable）* 和 *持久化的（Durable）*。
    - 完成阶段： 根据 执行阶段 结果形成的决议，应用通过 TM 发出的全局提交或回滚的请求给 TC，TC 命令 RM 驱动 分支事务 进行 Commit 或 Rollback。

    Seata 的所谓事务模式是指：运行在 Seata 全局事务框架下的 分支事务 的行为模式。准确地讲，应该叫作 分支事务模式。

    不同的 事务模式 区别在于 分支事务 使用不同的方式达到全局事务两个阶段的目标。即，回答以下两个问题：

    - 执行阶段 ：如何执行并 保证 执行结果满足是 *可回滚的（Rollbackable）* 和 *持久化的（Durable）*。
      - 完成阶段： 收到 TC 的命令后，如何做到分支的提交或回滚？

    我们以AT模式举例：

    ![at-mod](TB1NTuzOBr0gK0jSZFnXXbRRXXa-1330-924.png)

    - 执行阶段：
      - 可回滚：根据 SQL 解析结果，记录回滚日志
      - 持久化：回滚日志和业务 SQL 在同一个本地事务中提交到数据库
    - 完成阶段：
      - 分支提交：异步删除回滚日志记录
      - 分支回滚：依据回滚日志进行反向补偿更新

    ## Seata的XA模式

    XA模式：

    在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。

    ![xa-mod](TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png)

    - 执行阶段：
      - 可回滚：业务 SQL 操作放在 XA 分支中进行，由资源对 XA 协议的支持来保证 可回滚
      - 持久化：XA 分支完成后，执行 XA prepare，同样，由资源对 XA 协议的支持来保证 *持久化*（即，之后任何意外都不会造成无法回滚的情况）
    - 完成阶段：
      - 分支提交：执行 XA 分支的 commit
      - 分支回滚：执行 XA 分支的 rollback

    ### 为什么要在Seata中支持XA

    为什么要在 Seata 中增加 XA 模式呢？支持 XA 的意义在哪里呢？

    本质上，Seata 已经支持的 3 大事务模式：AT、TCC、Saga 都是 补偿型 的。

    补偿型 事务处理机制构建在 事务资源 之上（要么在中间件层面，要么在应用层面），事务资源 本身对分布式事务是无感知的。

    事务资源 对分布式事务的无感知存在一个根本性的问题：无法做到真正的 全局一致性 。

    比如，一条库存记录，处在 补偿型 事务处理过程中，由 100 扣减为 50。此时，仓库管理员连接数据库，查询统计库存，就看到当前的 50。之后，事务因为异外回滚，库存会被补偿回滚为 100。显然，仓库管理员查询统计到的 50 就是 脏 数据。所以补偿型事务是存在中间状态的（中途可能读到脏数据）

    ### XA的价值

    与 补偿型 不同，XA 协议 要求 事务资源 本身提供对规范和协议的支持。

    因为 事务资源 感知并参与分布式事务处理过程，所以 事务资源（如数据库）可以保障从任意视角对数据的访问有效隔离，满足全局数据一致性。

    比如，刚才提到的库存更新场景，XA 事务处理过程中，中间状态数据库存 50 由数据库本身保证，是不会仓库管理员的查询统计看到的。

    除了 全局一致性 这个根本性的价值外，支持 XA 还有如下几个方面的好处：

    1. 业务无侵入：和 AT 一样，XA 模式将是业务无侵入的，不给应用设计和开发带来额外负担。
    2. 数据库的支持广泛：XA 协议被主流关系型数据库广泛支持，不需要额外的适配即可使用。
    3. 多语言支持容易：因为不涉及 SQL 解析，XA 模式对 Seata 的 RM 的要求比较少。
    4. 传统基于 XA 应用的迁移：传统的，基于 XA 协议的应用，迁移到 Seata 平台，使用 XA 模式将更平滑。

    ## XA模式的使用

    我们从官方案例入手，具体的官方案例下载地址：https://github.com/seata/seata-samples

    官方案例演示图：

    ![image-20220211150003482](image-20220211150003482.png)

    案例解析：

    ![image-20220211155757596](image-20220211155757596.png)

    整体运行机制：

    ![xa-fw](TB1uM2OaSslXu8jSZFuXXXg7FXa-1330-958.png)

    ## 总结

    在当前的技术发展阶段，不存一个分布式事务处理机制可以完美满足所有场景的需求。

    一致性、可靠性、易用性、性能等诸多方面的系统设计约束，需要用不同的事务处理机制去满足。

    Seata 项目最核心的价值在于：构建一个全面解决分布式事务问题的 标准化 平台。

    基于 Seata，上层应用架构可以根据实际场景的需求，灵活选择合适的分布式事务解决方案。

    ![img](TB1lTSoOqL7gK0jSZFBXXXZZpXa-1028-528.png)

    XA 模式的加入，补齐了 Seata 在 全局一致性 场景下的缺口，形成 AT、TCC、Saga、XA 四大 事务模式 的版图，基本可以满足所有场景的分布式事务处理诉求。
</code></pre>
<p>Zookeeper(分布式协调服务):<br>    1. zookeeper集群中如果leader挂了,可以以极快的速度选举出新的leader,让集群恢复到可用状态,这过程一般在200ms以内完成,相较与redis哨兵模式的恢复速度要快很多,所以zookeeper在高可用这块比redis哨兵要更加优秀;<br>    2. zookeeper是一个目录树结构,zookeeper的每个node节点可以存储1M数据,不建议将zookeeper当作数据库使用,正是因为只存储少量数据,所以保证了zookeeper恢复速度快的特点;<br>    3. zookeeper常用于：统一配置管理、分布式锁、高可用节点选举主节点;<br>    4. Paxos:基于消息传递的一致性算法;<br>        Zxid编号:只会选择大于自己当前编号的提议;<br>        小岛(Island)——ZK Server Cluster;<br>        议员(Senator)——ZK Server;<br>        提议(Proposal)——ZNode Change(Create/Delete/SetData…);<br>        提议编号(PID)——Zxid(ZooKeeper Transaction Id)<br>        正式法令——所有ZNode及其数据<br>        总统——ZK Server Leader<br>    5. 顺序一致性：通过队列保证了客户端发送请求的顺序;<br>    6. 原子性：两阶段提交来保证；<br>    7. 统一视图：无论连接到集群的哪个节点，客户端都将看到相同的服务视图;<br>    8. 及时性：系统的客户端视图保证在特定时间范围内是最新的;<br>    9. 通过过半机制选举新的leader;<br>    10. Zookeeper分布式锁:<br>        首先要明确分布式锁要解决的：两个问题; (1.获取释放锁准确且快速、2.面对大量请求节点压力大)<br>            1. 所有client只能有一个人能够获取到锁;<br>            2. 锁释放问题,(获取锁的client异常了该如何释放锁和执行完毕释放锁); — 通过临时节点(session)实现;<br>            3. 锁过期了该如何处理;<br>            4. 获取到锁后执行的业务代码是否要加上分布式事务(可能会少卖);<br>            5. 锁释放了该如何通知其他客户端;<br>                5.1 主动轮询 — 弊端：延迟,压力;<br>                5.2 watch 解决延迟问题 — 弊端：watch所有节点压力过大;<br>                5.3 sequence(序列节点) + watch：watch序列中前一个客户端, 如果锁释放,zk只给前一个客户端发事件回调;</p>
<p>如何保证和提高系统的高可靠，高并发和高性能：</p>
<p>CPU飙高：<br>    1. load average 负载  一般使用top命令可以看到3个值, 分别是一分钟,五分钟,十五分钟的负载;<br>    2. CPU利用率  一般是顶部的cpus 后面的比率，下面具体的每行CPU利用率是指单个CPU的;</p>
<pre><code>top命令找到cpu占用高的进程
再使用jps -l确认是否是Java进程
top -Hp pid可以查看某个进程的线程信息
将线程的id转化成16进制,printf &#39;%x\n&#39;
导出Java堆栈信息，
    jstack pid &gt; stack.txt
根据导出的文件查找16进制的线程id号;
</code></pre>
<p>MQ相关：<br>    1. 如何防止消息重复消费<br>        保证幂等性<br>            1. 可在内存中维护一个set，只要从消息队列里面获取到一个消息，先查询这个消息在不在set里面，如果在表示已消费过，直接丢弃；如果不在，则在消费后将其加入set当中。<br>            2. 让生产者发送消息时，每条消息加一个带业务标记的全局的唯一id，然后消费时，将该id保存到redis里面。消费时先去redis里面查一下有么有，没有再消费。<br>    2. MQ如何保证消息不丢失<br>        1. 生产者保证消息投递成功<br>            采用同步方式发送,发送消息返回成功状态才算成功;<br>            消息发送异常或者返回非成功状态，可以重试;w<br>            可以使用事务消息,RocketMQ的事务消息机制就是为了保证零丢失来设计的<br>        2. 消息队列保证消息不会丢失<br>            确保消息持久化到磁盘，即刷盘机制<br>        3. 消费者保证消息成功消费<br>            Kafka：关闭手动提交，消费成功之后发送ack<br>            RabbitMQ：消费者回复ack确认<br>    3. 如何保证消息的有序性<br>        消费端定义一个队列按顺序将消息加入队列</p>
<p>MySQL如何保证事务隔离性的</p>
<p>Docker命令：<br>    进入容器方式一：<br>        docker exec -it 容器名/容器ID /bin/bash<br>    进入容器方式二：(推荐使用 exec 方式)<br>        docker attach 容器名/容器ID</p>
<p>Java中IO字节流和字符流</p>
<p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向数据源的流，这个数据源可以是文件，内存，或是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。<br>流的作用： 为数据源和目的地建立一个输送通道。<br>字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。Java中字符是采用Unicode标准，Unicode 编码中，一个英文字母或一个中文汉字为两个字节。在UTF-8编码中，一个中文字符是3个字节。<br>字符流与字节流的对比：<br>字节流一般用来处理图像、视频、音频、PPT、Word等类型的文件。<br>字符流一般用于处理纯文本类型的文件，如TXT文件等，但不能处理图像视频等非文本文件。<br>总结： 字节流可以处理一切文件，而字符流只能处理纯文本文件。<br>字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流本身就带有缓冲区，缓冲字符流相对于字符流效率提升就不是那么大了。<br>在整个Java.io包中最重要的就是5个类和一个接口。5个类指的是File、OutputStream、InputStream、Writer、Reader；一个接口指的是Serializable。掌握了这些IO的核心操作那么对于Java中的IO体系也就有了一个初步的认识了。</p>
<p>线程间的通信</p>
<p>@RequestBody<br>@RequestParam</p>

  </div>
</article>





    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>  
    <div id="vcomments" class="blog-post-comments"></div>
    <script>        
        new Valine({
            el: '#vcomments',
            visitor: true,
            appId: 'gqmHGHyrnzRPUSxqADLhUzlT-gzGzoHsz',
            appKey: 'q8uQ7rKeukTuQ3L35peaOhkC',
            placeholder: '好哥哥，说几句吧！',
            avatar: 'retro'
        })
    </script>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&text=全知识点复习"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&is_video=false&description=全知识点复习"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=全知识点复习&body=Check out this article: https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&title=全知识点复习"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://fate-re-zero.github.io/2022/10/07/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/%E5%85%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/&name=全知识点复习&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">2025 祥祥要起飞</a>
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/lib/particles/particles.min.js"></script>


<script src="/lib/typing/typing.min.js"></script>


<script src="/js/main.js"></script>


<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


